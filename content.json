{"pages":[{"title":"","text":"404 404 你懂的","link":"/404.html"},{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"About","text":"","link":"/about/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"git 常用命令手册","text":"收集工作中常用到的git 命令；只收集不易记忆的，常用的不在罗列都在脑子里。 分支管理本地仓库绑定远程仓库1git remote add origin &lt;remote repositorie&gt; 修改远程仓库地址12345678## 方式一 通过修改远程地址git remote set-url origin &lt;remote repositorie&gt; ## 方式二 先删除后添加git remote rm origingit remote add origin &lt;remote repositorie&gt; ## 方式三修改confige文件vim .git/confiG 查看当前的本地分支与远程分支的关联关系1git branch -vv 查看当前使用的分支号1git symbolic-ref --short -q HEAD 把本地分支与远程origin的分支进行关联处理12#&lt;branch name&gt; 代表变量\b，运行时替换为你远程的分支名git branch --set-upstream-to=origin/&lt;branch name&gt; 把当前本地分支推送到指定的远程分支12#&lt;branch name&gt; 代表变量\b，运行时替换为你远程的分支名git push origin &lt;branch name&gt; 编辑管理回滚未提交的代码12#本地所有修改的。没有的提交的，都返回到原来的状态git checkout . 回滚到某个版本节点12345##&lt;hash&gt; 代表你要回滚到的记录点的hash id#返回到某个节点，不保留修改。git reset --hard &lt;hash&gt;#返回到某个节点。保留修改 git reset --soft &lt;hash&gt;","link":"/2018/12/18/git-commond-manual-md/"},{"title":"记一次docker  容器把宿主机系统盘写满的事件","text":"环境信息 Docker version: 1.13.1 Linux version: CentOS Linux release 7.3.1611 (Core) 磁盘分配情况 12345678910[root@HZD-U-ISEE-STUDIO-01 ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/vda1 40G 6.9G 31G 19% /devtmpfs 3.9G 0 3.9G 0% /devtmpfs 3.9G 12K 3.9G 1% /dev/shmtmpfs 3.9G 35M 3.8G 1% /runtmpfs 3.9G 0 3.9G 0% /sys/fs/cgroup/dev/vdb1 99G 7.3G 87G 8% /alidata1tmpfs 783M 0 783M 0% /run/user/0tmpfs 783M 0 783M 0% /run/user/1000 问题描述 服务器在运行的过程中，发现不能创建新的docker容器 定位过程 查看CPU和内存 1top 1free -m 发现CPU和内存使用率正常 查看磁盘使用情况 由于一些容器会向nas盘写视频文件，就考虑到有可能是磁盘满了 检查后发现docker的虚拟盘把宿主机的系统盘写满了，导致宿主主机没有磁盘空间创建新的容器 解决方案 把docker 容器文件的存储位置迁移到容量更大的磁盘(“/alidata1”) 下面 解决过程 删除现有的docker容器 12docker stop `docker -a -q`docker rm `docker -a -q` 停止docker 服务 1systemctl stop docker 创建docker 文件存储目录 1mkdir -p /alidata1/docker/graph 修改配置文件 1vim /etc/sysconfig/docker 将文件中的OPTIONS那一行修改如下1OPTIONS='--selinux-enabled --log-driver=journald --signature-verification=false --graph=/alidata1/docker/graph' 重新加载配置 1systemctl daemon-reload 启动docker服务 1systemctl start docker 重新拉取镜像 1docker pull &lt;docker image id&gt; ps : 把原来’/var/lib/docker/‘ 目录下的文件拷贝过来，页可以看到镜像，并创建容器；但是容器启动后就消亡了。具体原因待定位，建议重新拉取镜像。 启动容器 1docker run &lt;....&gt; 验证结果 123456789101112131415[root@localhost ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/vda1 40G 6.9G 31G 19% /devtmpfs 3.9G 0 3.9G 0% /devtmpfs 3.9G 12K 3.9G 1% /dev/shmtmpfs 3.9G 35M 3.8G 1% /runtmpfs 3.9G 0 3.9G 0% /sys/fs/cgroup/dev/vdb1 99G 7.3G 87G 8% /alidata1tmpfs 783M 0 783M 0% /run/user/0tmpfs 783M 0 783M 0% /run/user/1000overlay 99G 7.3G 87G 8% /alidata1/docker/graph/overlay2/e071ea3439ff52a12ee127875b8511f5d05fdea236386495f99f4ece33bdfeb2/mergedshm 64M 0 64M 0% /alidata1/docker/graph/containers/841a2f9199f5da6159a15156762d5d488eee21c46237b82c192018d1264d6328/shmoverlay 99G 7.3G 87G 8% /alidata1/docker/graph/overlay2/850f00f1665f2c920e1d00aa836517e08e70df48d2fee0c3e4172dd2f95dd7f7/mergedoverlay 99G 7.3G 87G 8% /alidata1/docker/graph/overlay2/12e6e98dd0611e21d70378f32810f97fe86d1c30a9c9c562faf3bfb826d01244/merged[root@localhost ~]# 通过查看磁盘情况，发现新的容器文件已经写到数据盘下了 总结 docker 在生产环境运行的时候，不要把docker文件写在默认的系统盘”/var/lib/docker” 路径下","link":"/2019/05/23/docker-fills-system-volume01/"},{"title":"Docker 常用命令手册","text":"删除所有Docker容器1docker rm `docker ps -a -q` 删除所有Docker镜像1docker rmi `docker images -q` 登陆到Docker容器1docker exec -it &lt;containerId&gt; /bin/bash 通过 Dockerfile 打包镜像1234# 切换到Dockerfile 文件目录cd &lt;docker file path&gt;## 指定镜像名称&lt;iamge name&gt; 镜像路径&lt;image page&gt;docker build -t &lt;image name&gt; &lt;image_path&gt; 重新命名镜像1docker tag &lt;imageId&gt; &lt;image name&gt; 例子 1docker tag ca1b6b825289 huotaihe/selenium:latest 启动容器时通过启动命令绑定HOST1docker run --rm -ti --add-host=&lt;host1&gt;:&lt;ip1&gt; --add-host=&lt;host2&gt;:&lt;ip2&gt; &lt;imageId|imageName&gt; 例子 1docker run -ti --add-host=www.baidu.com:127.0.0.1 --add-host=www.google.com:127.0.0.1 centos 登录容器验证12345678910111213141516171819202122root@13c025719aaa /]# ping www.baidu.comPING www.baidu.com (127.0.0.1) 56(84) bytes of data.64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.048 ms64 bytes from localhost (127.0.0.1): icmp_seq=2 ttl=64 time=0.044 ms64 bytes from localhost (127.0.0.1): icmp_seq=3 ttl=64 time=0.038 ms64 bytes from localhost (127.0.0.1): icmp_seq=4 ttl=64 time=0.046 ms^C--- www.baidu.com ping statistics ---4 packets transmitted, 4 received, 0% packet loss, time 2999msrtt min/avg/max/mdev = 0.038/0.044/0.048/0.003 ms[root@13c025719aaa /]# ping www.google.comPING www.google.com (127.0.0.1) 56(84) bytes of data.64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.045 ms64 bytes from localhost (127.0.0.1): icmp_seq=2 ttl=64 time=0.042 ms64 bytes from localhost (127.0.0.1): icmp_seq=3 ttl=64 time=0.051 ms64 bytes from localhost (127.0.0.1): icmp_seq=4 ttl=64 time=0.043 ms64 bytes from localhost (127.0.0.1): icmp_seq=5 ttl=64 time=0.046 ms^C--- www.google.com ping statistics ---5 packets transmitted, 5 received, 0% packet loss, time 3999msrtt min/avg/max/mdev = 0.042/0.045/0.051/0.006 ms[root@13c025719aaa /]#","link":"/2018/12/13/docker-common-command-manual/"},{"title":"Linux 下批量重命名文件","text":"需求 需要将目录下文件明”?” 及以后的内容去掉 文件格式 123456[root@localhost]# ls |grep ?base.css?t=24bg-limited-count.png?hash=558ca0ebg-limited-normal.png?hash=3d4abb8bg-limited-time.png?hash=8deb2abbitmap.png?hash=c6835a4 实现Linux 实现1234## 先声明关键字[root@localhost]# b=\"\\\\?\"## 用循环批量修改for var in `ls |grep ?`; do mv -f $var ` echo ${var%$b*}`; done mac1234## 先声明关键字b=\"?\"## 用循环批量修改for var in `ls |grep \"?\"`; do mv -f $var `echo ${var%$b*}`; done 结果123456[root@localhost]# ls base.css bg-limited-count.png bg-limited-normal.png bg-limited-time.png bitmap.png 参考资料 https://blog.csdn.net/wuyinggui10000/article/details/52779364 https://www.cnblogs.com/pangblog/p/3243931.html","link":"/2019/06/05/linux-batch-rename-files/"},{"title":"Linux下在一行执行多条命令","text":"要实现在一行执行多条Linux命令，分三种情况： &amp;&amp; 1hexo clean &amp;&amp; hexo g 第2条命令只有在第1条命令成功执行之后才执行。当&amp;&amp;前的命令“hexo clean”成功执行后”hexo g”才执行，根据命令产生的退出码判断是否执行成功（0成功，非0失败）。 ||1hexo clean || hexo g 只有||前的命令“hexo clean”执行不成功（产生了一个非0的退出码）时，才执行后面的命令。 ;1hexo clean ; hexo g 顺序执行多条命令，当;号前的命令执行完（不管是否执行成功），才执行;后的命令。 参考：https://www.cnblogs.com/koreaseal/archive/2012/05/28/2522178.html","link":"/2018/12/13/linux-common-command-manual-01/"},{"title":"在Centos7 上搭建rabbitmq","text":"安装erlang123456## step1 通过yum安装 erlangyum install erlang## step2 检查erlang是否安装成功erl -version## teminal 输出如下内容说明安装成功Erlang (SMP,ASYNC_THREADS,HIPE) (BEAM) emulator version 5.10.4 安装rabbit mqRabbitMQ 最新版本地址：https://www.rabbitmq.com/releases/rabbitmq-server/current/ step1. 下载安装包1234## 切换到安装包存放目录cd /tmp## step1 下载安装包wget https://www.rabbitmq.com/releases/rabbitmq-server/current/rabbitmq-server-3.6.15-1.el6.noarch.rpm step2 通过rpm安装1yum install rabbitmq-server-3.6.15-1.el6.noarch.rpm step3 启动RabitMQ 服务1systemctl start rabbitmq-server.service step4 查看RabbitMQ 服务状态1systemctl status rabbitmq-server.service 输出如下信息说明启动成功123456789101112131415● rabbitmq-server.service - LSB: Enable AMQP service provided by RabbitMQ broker Loaded: loaded (/etc/rc.d/init.d/rabbitmq-server; bad; vendor preset: disabled) Active: active (running) since Mon 2019-05-06 20:44:37 CST; 19s ago Docs: man:systemd-sysv-generator(8) Process: 5455 ExecStart=/etc/rc.d/init.d/rabbitmq-server start (code=exited, status=0/SUCCESS) Memory: 67.7M CGroup: /system.slice/rabbitmq-server.service ├─5653 /bin/sh /etc/rc.d/init.d/rabbitmq-server start ├─5655 /bin/bash -c ulimit -S -c 0 &gt;/dev/null 2&gt;&amp;1 ; /usr/sbin/rabbitmq-server ├─5658 /bin/sh /usr/sbin/rabbitmq-server ├─5677 su rabbitmq -s /bin/sh -c /usr/lib/rabbitmq/bin/rabbitmq-server ├─5679 /bin/sh /usr/lib/rabbitmq/bin/rabbitmq-server ├─5868 /usr/lib64/erlang/erts-5.10.4/bin/beam.smp -W w -A 64 -P 1048576 -t 5000000 -stbt db -zdbbl 128000 -K true -B i -- -root /usr/lib64/erlang -progname erl -- -home /var/lib/rabbitmq -- -pa /usr/lib/rabbitmq/lib/rabbitmq... ├─6011 inet_gethost 4 └─6012 inet_gethost 4 step5 查看已经安装的插件1234## 切换到命令所在的目录cd /usr/sbin## 查看插件./rabbitmq-plugins lis 得到如下输出信息123456789101112131415161718192021222324252627282930313233Configured: E = explicitly enabled; e = implicitly enabled | Status: * = running on rabbit@GYB-T-ISEE-STUDIO-01 |/[ ] amqp_client 3.6.15[ ] cowboy 1.0.4[ ] cowlib 1.0.2[ ] rabbitmq_amqp1_0 3.6.15[ ] rabbitmq_auth_backend_ldap 3.6.15[ ] rabbitmq_auth_mechanism_ssl 3.6.15[ ] rabbitmq_consistent_hash_exchange 3.6.15[ ] rabbitmq_event_exchange 3.6.15[ ] rabbitmq_federation 3.6.15[ ] rabbitmq_federation_management 3.6.15[ ] rabbitmq_jms_topic_exchange 3.6.15[ ] rabbitmq_management 3.6.15[ ] rabbitmq_management_agent 3.6.15[ ] rabbitmq_management_visualiser 3.6.15[ ] rabbitmq_mqtt 3.6.15[ ] rabbitmq_random_exchange 3.6.15[ ] rabbitmq_recent_history_exchange 3.6.15[ ] rabbitmq_sharding 3.6.15[ ] rabbitmq_shovel 3.6.15[ ] rabbitmq_shovel_management 3.6.15[ ] rabbitmq_stomp 3.6.15[ ] rabbitmq_top 3.6.15[ ] rabbitmq_tracing 3.6.15[ ] rabbitmq_trust_store 3.6.15[ ] rabbitmq_web_dispatch 3.6.15[ ] rabbitmq_web_mqtt 3.6.15[ ] rabbitmq_web_mqtt_examples 3.6.15[ ] rabbitmq_web_stomp 3.6.15[ ] rabbitmq_web_stomp_examples 3.6.15[ ] sockjs 0.3.4 step6 安装web管理插件12cd /usr/sbinrabbitmq-plugins enable rabbitmq_management 输出如下信息说明启动成功123456789The following plugins have been enabled: amqp_client cowlib cowboy rabbitmq_web_dispatch rabbitmq_management_agent rabbitmq_managementApplying plugin configuration to rabbit@GYB-T-ISEE-STUDIO-01... started 6 plugins. step7 登录WEB管理台 添加admin用户 并赋予管理员权限 1234[root@localhost ~]# rabbitmqctl add_user admin adminCreating user \"admin\"[root@localhost ~]# rabbitmqctl set_user_tags admin administratorSetting tags for user \"admin\" to [administrator] 通过chrome问地址：http://localhost:15672/#/ 参考资料https://blog.csdn.net/cool_summer_moon/article/details/78803661https://blog.battcn.com/2017/08/20/linux/linux-centos7-ribbitmq/","link":"/2019/04/17/rabbitmq-install-on-centos7-md/"},{"title":"springboot 运行时修改日志打印级别","text":"序言 Spring Boot 在 spring-boot-starter-actuator 模块中提供了日志相关的 EndPoint，通过该 EndPoint 可以在运行时不需要重启服务就可以修改日志的打印级别。 解决了以前修改日志打印级别必须要重启服务的烦恼。 环境信息 spring boot 2.0.4.RELEASE(1.5以前的版本不适用该博文) JDK 1.8 POM 信息123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 启用loggers Endpoint出于安全因素考虑，依赖spring-boot-starter-actuator后，默认值启用了“/health”和“/info”两个 Endpoint可以通过如下配置启用所有的 endpoint 1management.endpoints.web.exposure.include=* 也可以通过该配置启用指定的 endpoint1management.endpoints.web.exposure.include=loggers,sessions 查看日志级别我们可以通过浏览器请求到 http://127.0.0.1:8080/actuator/loggers 来获取支持的日志等级，以及系统默认的日志等和各个包路径对应的日志级别。ps: 如下结果是精简过的，实际返回值很多1234567891011121314151617181920212223242526272829303132333435363738394041424344{ \"levels\":[ \"OFF\", \"ERROR\", \"WARN\", \"INFO\", \"DEBUG\", \"TRACE\" ], \"loggers\":{ \"ROOT\":{ \"configuredLevel\":\"INFO\", \"effectiveLevel\":\"INFO\" }, \"com\":{ \"configuredLevel\":null, \"effectiveLevel\":\"INFO\" }, \"com.github\":{ \"configuredLevel\":null, \"effectiveLevel\":\"INFO\" }, \"com.github.huotaihe\":{ \"configuredLevel\":null, \"effectiveLevel\":\"INFO\" }, \"com.github.huotaihe.spring\":{ \"configuredLevel\":null, \"effectiveLevel\":\"INFO\" }, \"com.github.huotaihe.spring.boot\":{ \"configuredLevel\":null, \"effectiveLevel\":\"INFO\" }, \"com.github.huotaihe.spring.boot.log\":{ \"configuredLevel\":null, \"effectiveLevel\":\"INFO\" }, \"com.github.huotaihe.spring.boot.log.Application\":{ \"configuredLevel\":null, \"effectiveLevel\":\"INFO\" } }} 配置日志级别编写日志输出类编写一个controller 输出各个级别的日志： 注意：日志门面类要使用 commons-log，而不能使用 sl4j；使用 sl4j 会导致日志级别不生效，具体原因会继续跟进。 123456789101112131415161718192021222324252627282930313233343536373839404142package com.github.huotaihe.spring.boot.log;import java.util.HashMap;import java.util.Map;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class LogController { private final static Logger LOG = LoggerFactory.getLogger(LogController.class); @GetMapping(\"/log\") public Map&lt;String, Object&gt; home() { if(LOG.isTraceEnabled()){ LOG.trace(\"trace level log\"); } if(LOG.isDebugEnabled()){ LOG.debug(\"debug level log\"); } if(LOG.isInfoEnabled()){ LOG.info(\"info level log\"); } if(LOG.isWarnEnabled()){ LOG.warn(\"warn level log\"); } if(LOG.isErrorEnabled()){ LOG.error(\"error level log\"); } Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(); result.put(\"status\", \"good\"); result.put(\"name\", \"abc\"); result.put(\"password\", \"abc\"); return result; }} 测试日志级别启动应用并访问http://127.0.0.1:8080/log控制台打印如图，Spring Boot 默认的 ROOT 日志级别是INFO。 修改指定包的日志级别通过/actuator/loggers端点提供的 POST 请求，修改包路径com.github.huotaihe.spring.boot.log 的日志级别为DEBUG。 发送 post 请求到http://127.0.0.1:8080/actuator/loggers/com.github.huotaihe.spring.boot.log header 信息必须添加Content-Type:application/json 浏览器通过 GET 方式访问如下地址http://127.0.0.1:8080/actuator/loggers/com.github.huotaihe.spring.boot.log查看当前包的目前日志级别 1234{\"configuredLevel\": \"DEBUG\",\"effectiveLevel\": \"DEBUG\"} 再次访问http://127.0.0.1:8080/log 得到 源代码github","link":"/2018/12/17/springboot-runtime-log-level/"},{"title":"Linux 常用命令手册","text":"收集工作中常用到的Linux 命令；只收集不易记忆的，常用的不在罗列都在脑子里。 目录管理查看当前目录总共占的容量，而不单独列出各子项占用的容量1du -sh 查看当前目录下一级子文件和子目录占用的磁盘容量1du -lh --max-depth=1 系统管理查看端口占用情况查看端口占用情况1lsof -i:&lt;port&gt; 查看操作系统的发行版本1lsb_release -a 例子 123456[root@localhost ~]# lsb_release -aLSB Version: :core-4.1-amd64:core-4.1-noarchDistributor ID: CentOSDescription: CentOS Linux release 7.3.1611 (Core)Release: 7.3.1611Codename: Core VIMvim 统计字符串出现次数（词频）1234567# &lt;pattern&gt; 是需要统计的字符串:%s/&lt;pattern&gt;//gn%s/Ø/\\r/g## 删除所有换行符号%s\\/\\n\\/\\/gc % - 操作区间，全文本；可以使用1, $或行区间替代 s - substitute - 查询字符串 // - 无替代文本。如果偏好，中间可以加任意字符！建议添加‘～’,重复上次查询 g - Replace all occurrences in the line. Without this argument, replacement occurs only for the first occurrence in each line.因此，如果不用此标志，就变成统计出现pattern的行数。 n - Report the number of matches, do not actually substitute.这是核心标志，也是达到目的的标志。同时也说明了为什么’//‘之间可以添加任意字符！","link":"/2018/12/20/linux-common-command-manual-md/"},{"title":"Spring Boot 集成Spring Session 实现全局Session","text":"Spring Session 简介Spring Session 为管理用户Session 信息提供了API和实现 Spring Session provides an API and implementations for managing a user’s session information. 特点 Spring Session 使应用支持集群回话变得更容易，而且不需要依赖于特定应用容器的解决方案。还提供如下透明集成： HttpSession - 可以独立于应用容器(i.e. tomcat)的方式 替换HttpSession，使用RESTful API的时候，支持在Headers中携带回话ID WebSocket - 提供在接收WebSocket消息时保持HttpSession活动的能力 WebSession 以独立于应用容器的方式替换 Spring WebFlux 的 web Session 模块 Spring Session 有一下几个模块组成： Spring Session Core - 提供Spring Session的核心API和能力 Spring Session Data Redis - 提供基于redis 的SessionRepository 和 ReactiveSessionRepository的实现，还有配置支持 Spring Session JDBC 提供基于数据库 的SessionRepository 和 ReactiveSessionRepository 的实现，还有配置支持 Spring Session Hazelcast 提供基于Hazelcast的SessionRepository 和 ReactiveSessionRepository 的实现，还有配置支持 Spring Boot 使用redis集中存储Spring Session 实战环境信息 Spring Boot - 2.1.3.RELEASE Redis - 4.0.11 引入pom依赖123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 配置redis 数据源123456spring: redis: database: 0 password: qweqwe123 host: 127.0.0.1 port: 6379 创建测试Controller1234567891011121314151617181920212223242526package com.github.huotaihe.springboot.learn.session;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.servlet.http.HttpSession;@RestController@RequestMapping(\"/session\")public class SessionTestController { @GetMapping(\"/setAtt\") public String test(HttpSession session){ session.setAttribute(\"age\", \"1\"); return \"1\"; } @GetMapping(\"/getAtt\") public String test2(HttpSession session) { String age = (String) session.getAttribute(\"age\"); return age; }} 启动Srping Boot 并请求 http://127.0.0.1:8080/session/setAtt 查看redis内容会发现redis 中已经存入了Session信息1234127.0.0.1:6379&gt; keys * 1) \"spring:session:sessions:10d169c5-cbad-4308-81c5-ef87b3e5c10b\" 2) \"spring:session:sessions:expires:10d169c5-cbad-4308-81c5-ef87b3e5c10b\" 3) \"spring:session:expirations:1560916620000\" 重启Spring Boot 并请求 http://127.0.0.1:8080/session/getAtt尝试获取上一步骤存入Seseion的属性，并且可以成功获取 至此整个实战过程已经完成了Spring Session 常用配置项说明1234567891011121314151617# SPRING SESSION (SessionProperties)## spring session 存储类型，如果只有一个Spring Session module 出现在classpath， Spring Boot 会自动使用存储实现，不需要制定该配置项；但是如果有多个实现存在，你必须通过该配置项选在使用哪个StoreType。spring.session.store-type= redis## Session 过期时间。如果时间后缀没有制定，默认单位是秒；如果没有配置，默认使用server.servlet.session.timeout的自动配置的值spring.session.timeout= 10000## Session repository 的过滤器执行顺序spring.session.servlet.filter-order=-2147483598 ## Session repository filter 分发类型spring.session.servlet.filter-dispatcher-types=async,error,request # SPRING SESSION REDIS (RedisSessionProperties)## session 过期表达式spring.session.redis.cleanup-cron=0 * * * * *# Sessions flush mode.spring.session.redis.flush-mode=on-save## session 在redis 中保存的命名空间 spring.session.redis.namespace=spring:session 工程源码： github： https://github.com/huotaihe/spring-boot-learn/tree/master/spring-redis-session 参考资料： https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/reference/htmlsingle/#boot-features-session https://docs.spring.io/spring-session/docs/2.1.5.RELEASE/reference/html5/guides/boot-redis.html https://spring.io/projects/spring-session","link":"/2019/06/18/spring-boot-session/"},{"title":"Spring Boot 搭建Oauth2 认证系统","text":"spring-security-oauth 简介OAuth2是一种广泛使用的授权框架。 Spring Security OAuth 提供了OAuth的实现，为OAuth 的提供者和消费者提供了支持，并且支持OAuth1和OAth2.0。 在学习spring security oauth 之前，需要掌握并理解OAuth，并且理解它解决了哪些应用场景，不了的话可以阅读它的官方文档；同时开发者也需要书序Spring和Spring Security 的工作原理。 环境信息 Spring Boot - 2.1.3.RELEASE JDK - 8 maven - 3.5.2 1. 搭建授权服务目前，Spring Security 还没有为OAuth2.0认证服务器提供实现。但是Spring Security OAuth项目 为该功能提供了支持，Spring Security OAuth 将被Spring Security 完全取代。在此之前，我们可以用spring-security-oauth2-autoconfigure 模块很容易的配置出OAuth2.0 授权服务器。 详细说明可以参考它的说明文档: https://docs.spring.io/spring-security-oauth2-boot/docs/2.1.6.RELEASE/reference/htmlsingle/ 利用spring-security-oauth2-boot 自动化配置搭建添加pom依赖123456789101112131415161718192021222324252627282930313233&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--启用 oauth2 需要引入security 和 oauth2-autoconfigure --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security.oauth.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2-autoconfigure&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在入口主类启用@EnableAuthorizationServer注解123456789@SpringBootApplication@EnableAuthorizationServerpublic class SpringBootOauthServerApplication { public static void main(String[] args) { SpringApplication.run(SpringBootOauthServerApplication.class, args); }} 添加相关配置123456spring.security.user.name=serverspring.security.user.password=qweqwe123security.oauth2.client.client-id=oauth2-serversecurity.oauth2.client.client-secret=qweqwe123## 官方说明文档并没有要求添加该项，但是 不加scope配置获取token会报错，security.oauth2.client.scope=1 启动配置oauth2 server 的springboot 工程测试授权服务器123## 发起获取token请求curl oauth2-server:qweqwe123@localhost:8080/oauth/token -d grant_type=password -d username=server -d password=qweqwe123 &gt; /token endpoint 的认证凭据是配置文件中的client-id和client-secret &gt; 用户的认证凭据是正常的spring security 用户 12## 控制台打印如下信息说明授权服务器配置成功{\"access_token\":\"aed587ec-a3cb-4953-89c8-5399d41dd8cd\",\"token_type\":\"bearer\",\"refresh_token\":\"5267069b-fc9a-490e-befb-ed11564e05e1\",\"expires_in\":43199,\"scope\":\"1\"}% 2. 搭建资源服务要使用Access Token 我们需要搭建一个资源服务器(Resource Server), 资源服务器可以是一个独立的服务，也可以和认证服务器搭建在同一个服务。创建资源服务器非常简单，只需要在主类上添加@EnableResourceServer, 并且提供一些配置允许服务器解码access token。 如果你的资源服务器同时也是认证服务器，应用一直知道如何解码access token 了，这是什么都不用配置。如果你的应用是一个独立的资源服务，你需要为应用提供如下几个配置项： security.oauth2.resource.user-info-uri 使用 Pivotal Web Services 的/me 资源 security.oauth2.resource.token-info-uri 如果你同时设置了user-info-uri和token-info-uri，你可以配置一个flag说明哪个配置优先(prefer-token-info=true 为默认配置)。 另外，如果你的tokens 是JWTS 可以替代user-info-uri 或者token-info-uri。我们可以配置一个security.oauth2.resource.jwt.key-value 用来对token进行本地解码(security.oauth2.resource.jwt.key-value 是验证秘钥)。校验秘钥可以是堆成秘钥也可以是PEM-encoded RSA 公钥。如果你没有key且它是公共的，您可以使用security.oauth2.resource.jwt.key-uri提供可以下载的URI（作为具有“value”字段的JSON对象）。 例如。 在PWS上：123 curl https://uaa.run.pivotal.io/token_key ## 返回值{\"kty\":\"RSA\",\"e\":\"AQAB\",\"use\":\"sig\",\"kid\":\"sha2-2017-01-20-key\",\"alg\":\"RS256\",\"value\":\"-----BEGIN PUBLIC KEY-----\\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAyH6kYCP29faDAUPKtei3\\nV/Zh8eCHyHRDHrD0iosvgHuaakK1AFHjD19ojuPiTQm8r8nEeQtHb6mDi1LvZ03e\\nEWxpvWwFfFVtCyBqWr5wn6IkY+ZFXfERLn2NCn6sMVxcFV12sUtuqD+jrW8MnTG7\\nhofQqxmVVKKsZiXCvUSzfiKxDgoiRuD3MJSoZ0nQTHVmYxlFHuhTEETuTqSPmOXd\\n/xJBVRi5WYCjt1aKRRZEz04zVEBVhVkr2H84qcVJHcfXFu4JM6dg0nmTjgd5cZUN\\ncwA1KhK2/Qru9N0xlk9FGD2cvrVCCPWFPvZ1W7U7PBWOSBBH6GergA+dk2vQr7Ho\\nlQIDAQAB\\n-----END PUBLIC KEY-----\",\"n\":\"AMh-pGAj9vX2gwFDyrXot1f2YfHgh8h0Qx6w9IqLL4B7mmpCtQBR4w9faI7j4k0JvK_JxHkLR2-pg4tS72dN3hFsab1sBXxVbQsgalq-cJ-iJGPmRV3xES59jQp-rDFcXBVddrFLbqg_o61vDJ0xu4aH0KsZlVSirGYlwr1Es34isQ4KIkbg9zCUqGdJ0Ex1ZmMZRR7oUxBE7k6kj5jl3f8SQVUYuVmAo7dWikUWRM9OM1RAVYVZK9h_OKnFSR3H1xbuCTOnYNJ5k44HeXGVDXMANSoStv0K7vTdMZZPRRg9nL61Qgj1hT72dVu1OzwVjkgQR-hnq4APnZNr0K-x6JU\"}% 此外，如果您的授权服务器具有返回一组JSON Web密钥（JWK）的端点，则可以配置security.oauth2.resource.jwk.key-set-uri123curl https://uaa.run.pivotal.io/token_keys## 返回值{\"keys\":[{\"kty\":\"RSA\",\"e\":\"AQAB\",\"use\":\"sig\",\"kid\":\"sha2-2017-01-20-key\",\"alg\":\"RS256\",\"value\":\"-----BEGIN PUBLIC KEY-----\\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAyH6kYCP29faDAUPKtei3\\nV/Zh8eCHyHRDHrD0iosvgHuaakK1AFHjD19ojuPiTQm8r8nEeQtHb6mDi1LvZ03e\\nEWxpvWwFfFVtCyBqWr5wn6IkY+ZFXfERLn2NCn6sMVxcFV12sUtuqD+jrW8MnTG7\\nhofQqxmVVKKsZiXCvUSzfiKxDgoiRuD3MJSoZ0nQTHVmYxlFHuhTEETuTqSPmOXd\\n/xJBVRi5WYCjt1aKRRZEz04zVEBVhVkr2H84qcVJHcfXFu4JM6dg0nmTjgd5cZUN\\ncwA1KhK2/Qru9N0xlk9FGD2cvrVCCPWFPvZ1W7U7PBWOSBBH6GergA+dk2vQr7Ho\\nlQIDAQAB\\n-----END PUBLIC KEY-----\",\"n\":\"AMh-pGAj9vX2gwFDyrXot1f2YfHgh8h0Qx6w9IqLL4B7mmpCtQBR4w9faI7j4k0JvK_JxHkLR2-pg4tS72dN3hFsab1sBXxVbQsgalq-cJ-iJGPmRV3xES59jQp-rDFcXBVddrFLbqg_o61vDJ0xu4aH0KsZlVSirGYlwr1Es34isQ4KIkbg9zCUqGdJ0Ex1ZmMZRR7oUxBE7k6kj5jl3f8SQVUYuVmAo7dWikUWRM9OM1RAVYVZK9h_OKnFSR3H1xbuCTOnYNJ5k44HeXGVDXMANSoStv0K7vTdMZZPRRg9nL61Qgj1hT72dVu1OzwVjkgQR-hnq4APnZNr0K-x6JU\"}]} 同时配置JWT和JWK 属性会引起报错。security.oauth2.resource.jwt.key-uri (或 security.oauth2.resource.jwt.key-value) 和 security.oauth2.resource.jwk.key-set-uri 应该只配置一个。 如果你是用security.oauth2.resource.jwt.key-uri 和security.oauth2.resource.jwk.key-set-uri，应用程序启动时，认证服务器需要保持运行。如果找不到密钥，它会记录警告，并告诉您如何解决问题。 OAuth2 资源服务器被security.oauth2.resource.filter-order 过滤器链保护，默认情况下在actuator endpoints 的保护过滤器之后。（因此，除非您更改顺序，否则执行器端点将保留在HTTP Basic上） 3. 搭建客户端服务要让你的额web-app变为变为OAuth2 客户端，只需要简单的添加@EnableOAuth2Client注解，Spring Boot 将会创建一个OAuth2ClientContext和OAuth2ProtectedResourceDetails，这些都是创建OAuth2RestOperations所必需的。Spring Boot 没有自动创建这样的bean，但是你可以轻松的创建。12345@Beanpublic OAuth2RestTemplate oauth2RestTemplate(OAuth2ClientContext oauth2ClientContext, OAuth2ProtectedResourceDetails details) { return new OAuth2RestTemplate(details, oauth2ClientContext);} 您可能希望添加限定符并检查配置，因为可能在应用程序中定义了多个RestTemplate。 此配置中使用security.oauth2.client.*作为凭据(与在授权服务器中的配置相同)，此外还需要授权服务器的授权和令牌URI。如下面配置项：12345678security: oauth2: client: clientId: bd1c0a783ccdd1c9b9e4 clientSecret: 1a9030fbca47a5b2c28e92f19050bb77824b5ad1 accessTokenUri: https://github.com/login/oauth/access_token userAuthorizationUri: https://github.com/login/oauth/authorize clientAuthenticationScheme: form 当你尝试使用Oauth2RestTemplate的时候,包含该配置的client将会重定向到Github进行认证。如果你已经登录到了Github，你甚至不会注意到他已经经过认证。只有你的应用运行在8080端口的时候，这些指定的凭证才会工作。(在Github或其他提供程序中注册您自己的客户端应用程序以获得更大的灵活性) 要限制客户端在获取访问令牌时要求的范围，可以设置security.oauth2.client.scope（逗号分隔或YAML中的数组）。 默认情况下，作用域为空，由Authorization Server决定默认值应该是什么，通常取决于它所拥有的客户端注册中的设置。 security.oauth2.client.client-authentication-scheme还有一个设置，默认是“header”(但是如果像Github一样，你的OAuth2 提供者不喜欢header 认证，你需要将其设置为“form”)。实际上，security.oauth2.client.* 属性绑定到了AuthorizationCodeResourceDetails实例，因此他的所有属性都可以指定。 在非web应用中你仍然可以创建一个OAuth2RestOperations，它仍然连接到security.oauth2.client.* 配置。在这种情况下，如果你使用它，它将是一个客户端凭证令牌授权(并且不再需要@EnableOAuth2Client和@EnableOAuth2SSo注解)。要组织该结构被定义，只需要从配置文件中删除security.oauth2.client.client-id 配置项(或者将值设为空字符串) 单点登录OAuth2 客户端可以用于从提供程序获取用户详细信息(如果此类功能可用)，然后将其转换成Spring Security的身份令牌验证。上面的资源服务器通过user-info-uri 属性支持者一点。这是基于OAuth2的单点登录的协议挤出，Spring Boot 通过提供@EnableOauth2Sso 注解使其易于参与。上面的Github客户端可以保护其所有资源，并使用Github /user/ endpoint进行验证，方法是添加注解并声明在哪里找到端点(除了上面已经列出的security.oauth2.client.* 配置) application.yml123456security: oauth2:# ... resource: userInfoUri: https://api.github.com/user preferTokenInfo: false 由于默认所有paths都是安全的，因此没有注解可以显示给未经身份验证的用户并邀请他们登录(通过访问/login路径或security.oauth2.sso.login-path指定的路径)。 自定义要保护的访问规则和路径，一遍可以添加home页面，可以将@EnableOAuth2Sso 添加到WebSecurityConfigureAdapter中，注释将使其被装饰和增强，并获得必要的部分以获取工作路径。例如，我们仅允许在“/”处对主页进行未经身份认证的访问，并保留其他所有内容的默认值。 1234567891011@Configurationpublic class WebSecurityConfiguration extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .mvcMatchers(\"/\").permitAll() .anyRequest().authenticated(); }} 另外请注意，由于默认请你赶快下所有endpoints都是安全的，因此这包括任何默认错误处理端点，例如端点”/error”。这意味着如果单点登录期间存在某些问题，需要重新定向到”/error”页面，这会导致身份提供程序和应用接收程序之间的无限重定向。 首先，仔细考虑使端点安全，因为您可能会发现行为只是不同问题的证据。 但是，可以通过将应用程序配置为允许“/ error”来解决此问题： 1234567891011@Configurationpublic class WebSecurityConfiguration extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .antMatchers(\"/error\").permitAll() .anyRequest().authenticated(); }} 参考资料 https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/htmlsingle/ https://projects.spring.io/spring-security-oauth/docs/oauth2.html https://docs.spring.io/spring-security-oauth2-boot/docs/2.0.0.RELEASE/reference/htmlsingle/#boot-features-security-oauth2-authorization-server","link":"/2019/06/21/spring-boot-oauth2/"},{"title":"springboot 打包时跳过单元测试","text":"通过修改pom.xml 在项目\b的pom.xml 文件的 &lt;properties&gt; 节点中增加如下节点12&lt;!-- maven方式跳过maven test, 等同 mvn package -Dmaven.test.skip=true --&gt;&lt;maven.test.skip&gt;true&lt;/maven.test.skip&gt; 通过命令行参数 \bmvn命令后添加参数 -Dmaven.test.skip 或者 -DskipTests123mvn package -Dmaven.test.skip=true# 或者mvn install -DskipTests","link":"/2018/12/18/springboot-skip-test/"}],"tags":[{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"Security","slug":"Security","link":"/tags/Security/"},{"name":"权限","slug":"权限","link":"/tags/权限/"},{"name":"temp","slug":"temp","link":"/tags/temp/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"Manual","slug":"Manual","link":"/tags/Manual/"},{"name":"rabbitmq","slug":"rabbitmq","link":"/tags/rabbitmq/"},{"name":"Springboot","slug":"Springboot","link":"/tags/Springboot/"},{"name":"log","slug":"log","link":"/tags/log/"},{"name":"session","slug":"session","link":"/tags/session/"},{"name":"oauth2","slug":"oauth2","link":"/tags/oauth2/"},{"name":"打包","slug":"打包","link":"/tags/打包/"}],"categories":[{"name":"Spring Security","slug":"Spring-Security","link":"/categories/Spring-Security/"},{"name":"temp","slug":"temp","link":"/categories/temp/"},{"name":"生产问题解决","slug":"生产问题解决","link":"/categories/生产问题解决/"},{"name":"Linux 常用命令手册","slug":"Linux-常用命令手册","link":"/categories/Linux-常用命令手册/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"},{"name":"深入spring boot","slug":"Spring/深入spring-boot","link":"/categories/Spring/深入spring-boot/"}]}